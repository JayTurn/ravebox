{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * api.ts\n * Handles api requests.\n */\n// Import the dependent interfaces.\nimport getConfig from 'next/config';\nimport fetch from 'isomorphic-fetch';\n// Retrieve the deployment config.\nconst {\n  publicRuntimeConfig\n} = getConfig();\n/**\n * Wrapper class to manage api requests.\n * @class API\n */\n\nexport default class API {\n  /**\n   * Static method to return the server API path.\n   * @method getServerPath\n   *\n   * @return string\n   */\n  static getServerPath() {\n    return publicRuntimeConfig.API_URI || '';\n  }\n  /**\n   * Static method to return the public path.\n   * @method getPublicPath\n   *\n   * @return string\n   */\n\n\n  static getPublicUri() {\n    return publicRuntimeConfig.PUBLIC_URI || '';\n  }\n  /**\n   * Static method for appending the api key query parameter.\n   * @method appendAPIKey\n   */\n\n\n  static appendAPIKey() {\n    return `?api_key=${publicRuntimeConfig.API_KEY}`;\n  }\n  /**\n   * Converts a response to JSON data.\n   * @method getJSON\n   *\n   * @param { Response } response - the response object.\n   *\n   * @return Promise<T>\n   */\n\n\n  static getJSON(response) {\n    // Return the JSON response.\n    return response.json();\n  }\n  /**\n   * Sets default header properties for requests.\n   * @method setDefaultHeaders\n   *\n   * @return RequestInit\n   */\n\n\n  static setDefaultHeaders() {\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      },\n      credentials: 'include',\n      method: 'GET'\n    };\n  }\n  /**\n   * Performs a request to the server api.\n   * @method request\n   *\n   * @param { string } path - the api path to be requested.\n   * @param { object } data - data to be submitted with post requests.\n   *\n   * @return Promise<T>\n   */\n\n\n  static async requestAPI(path, data) {\n    // If we have data, we need to merge the defaults with the provided data\n    // arguments.\n    if (data) {\n      data.headers = _objectSpread({\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      }, data.headers);\n      data.credentials = 'include';\n    } else {\n      data = API.setDefaultHeaders();\n    } // Define the api path to be requested.\n\n\n    path = `${API.getServerPath()}${path}`; // Perform the fetch of the data.\n\n    return fetch(path, data).then(API.getJSON).then(data => {\n      // Return the data in the generic form requested.\n      return data;\n    });\n  }\n  /**\n   * Provides a request wrapper supporting the cancellation of promise streams.\n   * @method request\n   *\n   * @param { Promise<T>} promise - the generic promise.\n   *\n   * @return RequestInterface<T>\n   */\n\n\n  static request(promise) {\n    // Define the cancellation flag used for determining which promise\n    // resolution is used.\n    let hasCanceled = false; // Return the RequestInterface object with a promise property and cancel\n    // function.\n\n    return {\n      promise: new Promise((resolve, reject) => {\n        promise.then(val => {\n          // If cancellation flag has been set to true, we should reject the\n          // request. The request rejection ensures a setState operation\n          // isn't fired after a component has been unmounted.\n          hasCanceled ? reject({\n            isCanceled: true\n          }) : resolve(val);\n        }, error => {\n          // @Todo: Introduce an error model to handle errors and submit\n          // logs.\n          hasCanceled ? reject({\n            isCanceled: true\n          }) : reject(error);\n        });\n      }),\n\n      cancel() {\n        // Updates the cancellation flag to prevent promises being resolved.\n        // With this flag, the promise will be rejected.\n        hasCanceled = true;\n      }\n\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/jay/Documents/projects/ravebox/client/src/utils/api/Api.model.ts"],"names":["getConfig","fetch","publicRuntimeConfig","API","getServerPath","API_URI","getPublicUri","PUBLIC_URI","appendAPIKey","API_KEY","getJSON","response","json","setDefaultHeaders","headers","credentials","method","requestAPI","path","data","then","request","promise","hasCanceled","Promise","resolve","reject","val","isCanceled","error","cancel"],"mappings":";;;;;;AAAA;;;;AAKA;AACA,OAAOA,SAAP,MAAsB,aAAtB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AAKA;AACA,MAAM;AAAEC,EAAAA;AAAF,IAA0BF,SAAS,EAAzC;AAEA;;;;;AAIA,eAAe,MAAMG,GAAN,CAAU;AAEvB;;;;;;AAMA,SAAcC,aAAd,GAAsC;AACpC,WAAOF,mBAAmB,CAACG,OAApB,IAA+B,EAAtC;AACD;AAED;;;;;;;;AAMA,SAAcC,YAAd,GAAqC;AACnC,WAAOJ,mBAAmB,CAACK,UAApB,IAAkC,EAAzC;AACD;AAED;;;;;;AAIA,SAAcC,YAAd,GAAqC;AACnC,WAAQ,YAAWN,mBAAmB,CAACO,OAAQ,EAA/C;AACD;AAED;;;;;;;;;;AAQA,SAAcC,OAAd,CAAyBC,QAAzB,EAAyD;AACvD;AACA,WAAOA,QAAQ,CAACC,IAAT,EAAP;AACD;AAED;;;;;;;;AAMA,SAAcC,iBAAd,GAA+C;AAC7C,WAAO;AACLC,MAAAA,OAAO,EAAE;AACP,wBAAgB,kBADT;AAEP,kBAAU;AAFH,OADJ;AAKLC,MAAAA,WAAW,EAAE,SALR;AAMLC,MAAAA,MAAM,EAAE;AANH,KAAP;AAQD;AAED;;;;;;;;;;;AASA,eAAoBC,UAApB,CAAkCC,IAAlC,EAAgDC,IAAhD,EAAgF;AAE9E;AACA;AACA,QAAIA,IAAJ,EAAU;AACRA,MAAAA,IAAI,CAACL,OAAL;AACE,wBAAgB,kBADlB;AAEE,kBAAU;AAFZ,SAGKK,IAAI,CAACL,OAHV;AAMAK,MAAAA,IAAI,CAACJ,WAAL,GAAmB,SAAnB;AACD,KARD,MAQO;AACLI,MAAAA,IAAI,GAAGhB,GAAG,CAACU,iBAAJ,EAAP;AACD,KAd6E,CAgB9E;;;AACAK,IAAAA,IAAI,GAAI,GAAEf,GAAG,CAACC,aAAJ,EAAoB,GAAEc,IAAK,EAArC,CAjB8E,CAmB9E;;AACA,WAAOjB,KAAK,CAACiB,IAAD,EAAOC,IAAP,CAAL,CACJC,IADI,CACCjB,GAAG,CAACO,OADL,EAEJU,IAFI,CAEED,IAAD,IAAe;AACnB;AACA,aAAOA,IAAP;AACD,KALI,CAAP;AAMD;AAED;;;;;;;;;;AAQA,SAAcE,OAAd,CAAyBC,OAAzB,EAAoE;AAClE;AACA;AACA,QAAIC,WAAW,GAAG,KAAlB,CAHkE,CAKlE;AACA;;AACA,WAAO;AACLD,MAAAA,OAAO,EAAE,IAAIE,OAAJ,CAAY,CAACC,OAAD,EAAoBC,MAApB,KAAyC;AAC5DJ,QAAAA,OAAO,CAACF,IAAR,CACGO,GAAD,IAAY;AACV;AACA;AACA;AACAJ,UAAAA,WAAW,GAAGG,MAAM,CAAC;AAACE,YAAAA,UAAU,EAAE;AAAb,WAAD,CAAT,GAAgCH,OAAO,CAACE,GAAD,CAAlD;AACD,SANH,EAOGE,KAAD,IAAe;AACb;AACA;AACAN,UAAAA,WAAW,GAAGG,MAAM,CAAC;AAACE,YAAAA,UAAU,EAAE;AAAb,WAAD,CAAT,GAAgCF,MAAM,CAACG,KAAD,CAAjD;AACD,SAXH;AAaD,OAdQ,CADJ;;AAgBLC,MAAAA,MAAM,GAAG;AACP;AACA;AACAP,QAAAA,WAAW,GAAG,IAAd;AACD;;AApBI,KAAP;AAsBD;;AAtIsB","sourcesContent":["/**\n * api.ts\n * Handles api requests.\n */\n\n// Import the dependent interfaces.\nimport getConfig from 'next/config';\nimport fetch from 'isomorphic-fetch';\nimport {\n  RequestInterface\n} from './Api.interface';\n\n// Retrieve the deployment config.\nconst { publicRuntimeConfig } = getConfig();\n\n/**\n * Wrapper class to manage api requests.\n * @class API\n */\nexport default class API {\n\n  /**\n   * Static method to return the server API path.\n   * @method getServerPath\n   *\n   * @return string\n   */\n  public static getServerPath(): string {\n    return publicRuntimeConfig.API_URI || '';\n  }\n\n  /**\n   * Static method to return the public path.\n   * @method getPublicPath\n   *\n   * @return string\n   */\n  public static getPublicUri(): string {\n    return publicRuntimeConfig.PUBLIC_URI || '';\n  }\n\n  /**\n   * Static method for appending the api key query parameter.\n   * @method appendAPIKey\n   */\n  public static appendAPIKey(): string {\n    return `?api_key=${publicRuntimeConfig.API_KEY}`;\n  }\n\n  /**\n   * Converts a response to JSON data.\n   * @method getJSON\n   *\n   * @param { Response } response - the response object.\n   *\n   * @return Promise<T>\n   */\n  public static getJSON<T>(response: Response): Promise<T> {\n    // Return the JSON response.\n    return response.json();\n  }\n\n  /**\n   * Sets default header properties for requests.\n   * @method setDefaultHeaders\n   *\n   * @return RequestInit\n   */\n  public static setDefaultHeaders(): RequestInit {\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      },\n      credentials: 'include',\n      method: 'GET'\n    };\n  }\n\n  /**\n   * Performs a request to the server api.\n   * @method request\n   *\n   * @param { string } path - the api path to be requested.\n   * @param { object } data - data to be submitted with post requests.\n   *\n   * @return Promise<T>\n   */\n  public static async requestAPI<T>(path: string, data?: RequestInit): Promise<T> {\n\n    // If we have data, we need to merge the defaults with the provided data\n    // arguments.\n    if (data) {\n      data.headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n        ...data.headers,\n      };\n\n      data.credentials = 'include';\n    } else {\n      data = API.setDefaultHeaders();\n    }\n\n    // Define the api path to be requested.\n    path = `${API.getServerPath()}${path}`;\n\n    // Perform the fetch of the data.\n    return fetch(path, data)\n      .then(API.getJSON)\n      .then((data: any) => {\n        // Return the data in the generic form requested.\n        return data as T;\n      });\n  }\n\n  /**\n   * Provides a request wrapper supporting the cancellation of promise streams.\n   * @method request\n   *\n   * @param { Promise<T>} promise - the generic promise.\n   *\n   * @return RequestInterface<T>\n   */\n  public static request<T>(promise: Promise<T>): RequestInterface<T>  {\n    // Define the cancellation flag used for determining which promise\n    // resolution is used.\n    let hasCanceled = false;\n\n    // Return the RequestInterface object with a promise property and cancel\n    // function.\n    return {\n      promise: new Promise((resolve: Function, reject: Function) => {\n        promise.then(\n          (val: T) => {\n            // If cancellation flag has been set to true, we should reject the\n            // request. The request rejection ensures a setState operation\n            // isn't fired after a component has been unmounted.\n            hasCanceled ? reject({isCanceled: true}) : resolve(val);\n          },\n          (error: {}) => {\n            // @Todo: Introduce an error model to handle errors and submit\n            // logs.\n            hasCanceled ? reject({isCanceled: true}) : reject(error);\n          }\n        );\n      }),\n      cancel() {\n        // Updates the cancellation flag to prevent promises being resolved.\n        // With this flag, the promise will be rejected.\n        hasCanceled = true;\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}